## 指针数组和数组指针

```c_cpp
#include <stdio.h>
int main()
{
char *p[5] = {"ndnmd", "wdnm", "wdn", "wd", "w"};
for (int i = 0; i < 5; i++)
{
    printf("%c\n", p[i]);
}
char a[] = {"niubi"};
printf("%d\n", sizeof(a));
char *b = a;
printf("%d\n", sizeof(b));
}
```

```c_cpp
//你以为里面放的是字符,其实是地址,倒不如说
//所有字符串都是地址
//当你用&p[i]时跑出来8字节地址,实际就是指针大小
//也就是指针套着地址套着字符
//当你用*p[i]时%s读不出来,因为它读首地址
//%c读的出来,只有一个字符.%p读出ascll码
//让我想起来,普通的指针也是指针放地址,地址放值
//*就是取地址的值,不*就是地址
```

## 指针和二维数组

```c_cpp
*(arr +i)==arr[i]
*(*(arr+i)+j)==arr[i][j]
```

```c_cpp
初始化二维数组是可以偷懒的：
int array[2][3]={{0,1,2},{3,4,5}};
可以写成
int array[][3]={{0,1,2},{3,4,5}};
```

![](https://raw.githubusercontent.com/shadow-aaa/markdown_photo/main/PicGo/202304211939916.png)

## void指针和null指针

用void指针可以赋值所有类型的指针,打印的时候需要类型转换.

当你还不清楚指针要指向哪里是,就初始化为null,不要让它变成野指针.

## 指向指针的指针

![](https://raw.githubusercontent.com/shadow-aaa/markdown_photo/main/PicGo/202304211943124.png)

## 字符串输出

```
	char* s = "HelloWorld";
	cout<<s<<endl; //s是字符串的首地址，但却输出HelloWorld
	cout<<*s<<endl;  //输出H
	cout<<*(s+1)<<endl;  //输出e，s+1是第二个字符的地址
  cout <<static_cast<void *>(s) << endl; //此时输出的才是字符串地址
```

```
	char *p[6]={"ABCD","EFGH","IJKL","MNOP"};
	int i;
    for(i=0;i<4;i++)
        cout<<p+i<<endl;    //输出指针数组中的每个指针的首地址
	for(i=0;i<4;i++)        //*(p+i)=p[i] 为什么呢?
		cout<<p[i]<<endl;  //输出每个字符串，实际上p[i]为第i个字符串的首地址
	for(i=0;i<4;i++) 
		cout<<*p[i];  //输出每个字符串第一个字符AEIM
	cout<<endl;
	for(i=0;i<4;i++) 
		cout<<*(p[i]+1); //输出每个字符串第二个字符BFJN
```

## c++创建二维数组

```c_cpp
int** grid = new int*[rows];
for (int i = 0; i < rows; i++)
	gird[i] = new int[cols];

```

## 类与对象-构造函数

如果提供了有参构造函数,那么系统默认的无参构造函数就会消失,无参初始化将会报错.所以当你自定义构造函数时,最好有无参都写.

## 类与对象-析构函数

![栈的析构思想](https://raw.githubusercontent.com/shadow-aaa/markdown_photo/main/PicGo/202304211940476.png)

**栈的析构思想**

同级别,先构造后析构**先释放data4后data2**

一般情况下,空的析构函数就足够了,但是如果一个类有指针成员,这个类必须写析构函数,指向这个指针成员.**否则,指针指向的堆区再也找不到,会内存泄漏**(链表知识,我不会),delete[] p;

## 拷贝构造函数

拷贝构造函数本质是构造函数

调用时机:

- **旧对象** 初始化 **新对象**时调用
- 作为实参拷贝给形参
- 函数返回对象(VS里有(现在可能也没了),linux,qtcreater里没有)

**当前赋初值的才是新对象,其它都是旧对象**

```c_cpp
data ob1(10);//此句ob1新对象
data ob2 = ob1;//此句ob2新对象,调用拷贝构造
```

 定义:

```c_cpp
Data(const Data &ob)
{
  
}
```

也会取消掉**默认的拷贝构造(浅拷贝)**

如果用户定义了拷贝构造或者有参构造都会屏蔽无参构造。

## 数组越界详解

[http://c.biancheng.net/view/366.html](https://)

```c_cpp
#define PASSWORD "123456"
int Test(char *str)
{
    int flag;
    char buffer[7];
    flag=strcmp(str,PASSWORD);
    strcpy(buffer,str);
    return flag;
}
int main(void)
{
    int flag=0;
    char str[1024];
    while(1)
    {
        printf("请输入密码：  ");
        scanf（"%s",str);
        flag = Test(str);
        if(flag)
        {
            printf("密码错误！\n");
        }
            else
            {
                printf("密码正确！\n");
            }
    }
    return 0;
}
```

上面的示例代码模拟了一个密码验证的例子，它将用户输入的密码与宏定义中的密码“123456”进行比较。很显然，**本示例中最大的设计漏洞就在于 Test() 函数中的 strcpy(buffer,str) 调用**。

由于程序将用户输入的字符串原封不动地复制到 Test() 函数的数组 char buffer[7] 中。因此，当用户的**输入大于 7 个字符的缓冲区尺寸**时，就会发生数组越界错误，这也就是大家所谓的**缓冲区溢出(Buffer overflow)漏洞**。但是要注意，如果这个时候我们根据缓冲区溢出发生的具体情况填充缓冲区，不但可以避免程序崩溃，还会影响到程序的执行流程，甚至会让程序去执行缓冲区里的代码。示例运行结果为：

请输入密码:12345
密码错误！
请输入密码:123456
密码正确！
请输入密码:1234567
密码正确！
请输入密码:aaaaaaa
密码正确！
请输入密码:0123456
密码错误！
请输入密码:

在示例代码中，flag 变量实际上是一个标志变量，其值将决定着程序是进入“密码错误”的流程（非 0）还是“密码正确”的流程（0）。当我们输入错误的字符串“1234567”或者“aaaaaaa”，程序也都会输出“密码正确”。但在输入“0123456”的时候，程序却输出“密码错误”，这究竟是为什么呢？

其实，原因很简单。当调用 Test() 函数时，系统将会给它分配一片连续的内存空间，而变量 char buffer[7] 与 int flag 将会紧挨着进行存储，用户输入的字符串将会被复制进 buffer[7] 中。如果这个时候，我们输入的字符串数量超过 6 个（注意，有字符串截断符也算一个），那么**超出的部分将破坏掉与它紧邻着的 flag 变量**的内容。

当输入的密码不是宏定义的“123456”时，字符串比较将返回 1 或 -1。我们都知道，内存中的数据按照** 4 字节**（DWORD）**逆序存储**，所以当 flag 为 1 时，在内存中存储的是 0x01000000。如果我们输入包含 7 个字符的错误密码，如“aaaaaaa”，那么字符串截断符 0x00 将写入 flag 变量，这样溢出数组的一个字节 0x00 将恰好把逆序存放的 flag 变量改为 0x00000000。在函数返回后，一旦 main 函数的 flag 为 0，就会输出“密码正确”。这样，我们就用错误的密码得到了正确密码的运行效果。

而对于“0123456”，因为在进行字符串的大小比较时，它小于“123456”，flag的值是 -1，在内存中将按照补码存放负数，所以实际存储的不是 0x01000000 而是 0xffffffff。那么字符串截断后符 0x00 淹没后，变成 0x00ffffff，还是非 0，所以没有进入正确分支。

***

上述结果无法复现....简单来说就是strcpy坑人,经常导致缓存区溢出吧

***

要避免数组越界，除了上面所阐述的显式指定数组的边界之外，还可以在数组使用之前进行越界检查，检查数组的界限和字符串（也以数组的方式存放）的结束，以保证数组索引值位于合法的范围之内。例如，在写处理数组的函数时，一般应该有一个**范围参数**；**在处理字符串时总检查是否遇到空字符‘\0’。**

## 浅拷贝和深拷贝

**如果类中没有指针成员,不用实现拷贝构造和析构函数**

## 类指针数组使用构造函数

new (&p[i]) Date(y, m, d);
